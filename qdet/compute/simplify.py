
from qiskit import QuantumCircuit, transpile
from qiskit.transpiler import PassManager
from qiskit.transpiler.passes import Optimize1qGates, CommutativeCancellation
from typing import List


class CircuitOptimizer:
    """
    Optimizes Quantum Circuits to reduce depth and cost.
    
    Philosophy:
    In Data Engineering, efficiency is money. Quantum circuits generated by
    automated encoders often have redundant gates (e.g., H-H cancel out).
    This module "cleans" the circuits to reduce cost and noise before execution.
    
    Cost Savings:
    - 10% depth reduction on 1 million jobs = Significant QPU time savings
    - Reduced entanglement/noise on real hardware
    - Lower transpilation overhead
    
    Example:
        >>> optimizer = CircuitOptimizer(level=3)
        >>> optimized_circuit = optimizer.optimize(circuit)
        >>> optimized_circuits = optimizer.optimize_batch(circuit_list)
    """
    
    def __init__(self, level: int = 3):
        """
        Initialize Circuit Optimizer.
        
        Parameters
        ----------
        level : int
            Optimization level (0-3):
            - 0: No optimization (fastest, lowest quality)
            - 1: Light optimization
            - 2: Medium optimization
            - 3: Heavy optimization (slowest, best quality) [DEFAULT]
        """
        if not 0 <= level <= 3:
            raise ValueError("Optimization level must be 0-3")
        
        self.level = level
        
        self.pm = PassManager([
            Optimize1qGates(),
            CommutativeCancellation()
        ])
        
        print(f"--- Circuit Optimizer Initialized (Level {level}) ---")

    def optimize(self, circuit: QuantumCircuit) -> QuantumCircuit:
        """
        Optimizes a single quantum circuit.
        
        Optimization passes applied:
        1. Optimize1qGates: Combine adjacent single-qubit gates
        2. CommutativeCancellation: Cancel gates that commute and cancel
        3. Transpilation: Map to basis gates, compile for backend
        
        Parameters
        ----------
        circuit : QuantumCircuit
            Quantum circuit to optimize
            
        Returns
        -------
        QuantumCircuit
            Optimized circuit with reduced depth/cost
        """
        optimized_qc = transpile(circuit, optimization_level=self.level)
        
        optimized_qc = self.pm.run(optimized_qc)
        
        return optimized_qc

    def optimize_batch(self, circuits: List[QuantumCircuit]) -> List[QuantumCircuit]:
        """
        Optimizes a batch of quantum circuits (e.g., from QuantumDataLoader).
        
        Useful for processing large numbers of circuits before QPU submission.
        
        Parameters
        ----------
        circuits : List[QuantumCircuit]
            List of quantum circuits to optimize
            
        Returns
        -------
        List[QuantumCircuit]
            List of optimized circuits (same order)
        """
        print(f"--- Optimizing batch of {len(circuits)} circuits ---")
        optimized_circuits = [self.optimize(qc) for qc in circuits]
        print(f"--- Batch optimization complete ---")
        return optimized_circuits

    def estimate_savings(self, original_circuit: QuantumCircuit, optimized_circuit: QuantumCircuit) -> dict:
        """
        Estimates cost/depth savings from optimization.
        
        Parameters
        ----------
        original_circuit : QuantumCircuit
            Original circuit before optimization
        optimized_circuit : QuantumCircuit
            Circuit after optimization
            
        Returns
        -------
        dict
            Dictionary with depth, gate count, and cost metrics
        """
        orig_depth = original_circuit.depth()
        opt_depth = optimized_circuit.depth()
        
        orig_gates = len(original_circuit)
        opt_gates = len(optimized_circuit)
        
        depth_saved = (1 - opt_depth / orig_depth) * 100 if orig_depth > 0 else 0
        gates_saved = (1 - opt_gates / orig_gates) * 100 if orig_gates > 0 else 0
        
        return {
            "original_depth": orig_depth,
            "optimized_depth": opt_depth,
            "depth_reduction_%": depth_saved,
            "original_gates": orig_gates,
            "optimized_gates": opt_gates,
            "gates_reduction_%": gates_saved,
        }
